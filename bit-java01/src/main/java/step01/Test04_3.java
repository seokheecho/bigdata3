/* 부동소수점(floating point) 값을 저장하는 메모리 크기
 * => 4바이트와 8바이트 크기의 부동소수점이 있다.
 * => 4바이트 부동소수점 값의 범위 
 *    - 보통 10진수에서 소수점을 떼어낸 후 7자리까지 유효하다고 표현한다.
 *    - 7자리의 10진수도 때론 2진수로 바뀔 때 가수부 23비트를 넘을 수 있기 때문에
 *      100% 안전하진 않다.
 *    - 그래서 정수 값을 저장할 때는 무조건 정수형으로 표현하고,
 *      부동소수점으로 값을 표현할 때는 가능한 유효자리 범위의 수로 표현하되,
 *      그래서 값이 짤릴 수 있다는 것을 이해해야 한다. 
 */
package step01;

public class Test04_3 {

  public static void main(String[] args) {
    // 4바이트 부동소수점을 표현할 때는 반드시 숫자 끝에 
    // 대문자 F 또는 소문자 f를 붙여야 한다.
    System.out.println(9.876876f); // 주로 소문자를 쓴다.
    System.out.println(9.876876F);
    System.out.println(987687.6f); 
    
    // 유효자릿수 7자리를 넘는다면?
    System.out.println(987687.63f); // 끝 3 짤린다.
    System.out.println(9.8768763f); // 끝 3 짤린다.
    System.out.println(987687.69f); // 끝 9 반올림 처리된다.
    
    // 유효자릿수 7자리를 넘어도 괜찮네요!
    // 이유?
    // => 다음 수와 같이 유효자릿수 7자리를 넘어도 제대로 저장되는 경우도 있다.
    // => 2진수로 바꿨을 때 부동소수점 메모리의 가수부(23비트) 영역안에 
    //     값이 짤리지 않고 저장되기 때문이다.
    // 권고!
    // 그래도 가능한 코딩할 때 유효자릿수 7자리를 넘지 않도록 하라!
    // 혹 유효자릿수 7자리 범위 내에 있더라도 2진수로 바꿨을 때 
    // 가수부(23비트)를 넘어서는 경우 값이 짤리 수 있다는 것도 항상 염두해둬라!
    System.out.println(134217728f); 

    // 유효자릿수 7자리를 넘지 않아도 값이 짤리는 경우?
    // => 소수점 이하의 수를 2진수로 바꿀 때 가수부 23비트 크기의 
    //    2진수 값으로 딱 떨어지지 않는 경우가 있다.
    //    이런 경우 가수부 23비트에 넣을 때 나머지 비트들의 값은 짤린다.
    // => 이런 경우를 대비해 보통 프로그래밍 언어에서는
    //    부동소수점 값을 메모리에서 꺼낼 때 보정 작업을 수행한다.
    //    이런 보정 작업을 거치면 얼추 원래의 값으로 뽑을 수 있다.
    // => 주의!
    //    보정 작업을 통해서도 원래의 값으로 복원 못하는 경우도 있음을 항상 염두해둬라!
    System.out.println(12.754f); 

    // 다음은 0.754를 2진수로 변환하는 것을 표현한 코드이다. 참고하라!
    int value = 754;
    for (int i = 0; i < 40; i++) {
      value *= 2;
      System.out.printf("%d, %d\n", (int)(value / 1000), (value = value % 1000));
    }
  }

}
