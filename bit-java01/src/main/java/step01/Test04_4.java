/* 부동소수점(floating point) 값을 저장하는 메모리 크기 II
 * => 4바이트와 8바이트 크기의 부동소수점이 있다.
 * => 8바이트 부동소수점 값의 범위 
 *    [부호비트(1)][지수부(11)][가수부(52)]
 *    가수부가 52비트이기 때문에,
 *    대충 2^52 * 2 = 2^53으로 계산된 10진수의 자릿수가 유효자릿수가 된다.
 * => 잠깐? 가수부가 52비트인데 왜 2의 53승으로 계산하나요?
 *    - 가수부에 값을 넣을 때 맨 앞의 1비트를 날린다. 
 *      그러니 실제로는 1비트를 추가한 값이 된다.
 * => 즉 대략 15자리까지는 가수부에 제대로 저장할 수 있다.
 *    그런데 이전 예제에서 봤듯이,
 *    15자리를 초과하더라도 되는 값이 있다.
 *    15자리 보다 작은 수라도 값이 짤리는 경우도 있다.
 *    이유?
 *    2진수로 바꿨을 때 가수부 52비트 안에 저장될 수 있으면 
 *    값이 짤리지 않고 제대로 저장될 것이고,
 *    아니면 값이 짤려서 저장될 것이다.
 */
package step01;

public class Test04_4 {

  public static void main(String[] args) {
    // 8바이트 부동소수점을 표현할 때는 숫자 끝에 D 또는 d를 붙인다. 
    System.out.println(9.87654321987654d);
    System.out.println(98765432198765.4D);
    System.out.println(98765432198765.4); // D를 안 붙여도 된다. 보통 안 붙인다.
    
    // 유효자릿수 15자리를 넘어서면?
    System.out.println(9.876543219876547); // 정상 
    System.out.println(987654321987654.7); // 반올림 처리됨
    // 즉, 16자리인 경우 깨질 가능성이 급격히 높아진다.


    // 64비트로 부동소수점을 저장할 경우,
    // 32비트로 부동소수점을 저장하는 것 보다 약 2배 더 정밀한 값을 
    // 저장할 수 있어서 64비트 부동소수점을 "배정도"라고 부른다.
    // 32비트 부동소수점은 "단정도"라고 부른다.
    // 그래서 32비트 부동소수점을 "float"이라 부르고,
    // 64비트 부동소수점을 "double"이라 부른다.
  }

}
