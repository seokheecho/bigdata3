// 오버라이딩 불가 메서드 만들기
package step16.other;

// 로컬 변수 앞에 final을 붙이면 상수 값으로 취급한다.
public class MyClass5 {
  //final int x; // final 필드는 반드시 변수 선언할 때 값을 줘야 한다. 안주면 컴파일 오류!
  final int x = 200; //OK!
  
  public void m1() {
    // 일반 로컬 변수
    int a;
    
    // 언제든지 값을 바꿀 수 있다.
    a = 20;
    a = 30;
    a = 40;
    
    // 상수 로컬 변수
    // => 로컬 변수는 필드와 달리 변수 선언할 때 값을 지정할 필요는 없다.
    final int b;
    
    b = 10;
    //b = 20; // 값을 딱 한 번만 저장할 수 있다. 컴파일 오류!
  }
  
  // 로컬 변수에 final을 지정할 경우:
  // => 일반 로컬 변수가 아니라 주로 파라미터에 final을 붙인다.
  // => 즉 파라미터의 목적을 잃어버리지 않게 하기 위함이다.
  // => 파라미터의 목적?
  //    - 메서드가 작업할 때 사용할 값을 주는 것!
  public float compute(final float interest, final int money) {
    // 이자율에 따라 최종 금액을 계산하는 함수가 있다고 가정하자!
    
    // 일반 파라미터 변수는 중간에 값을 바꿔도 막을 방법이 없다.
    // 파라미터의 값을 그냥 사용해야지 다음과 같이 값을 바꾼다? 
    // 이게 과연 바람직한가! 파라미터 변수가 뭔가?
    // 외부에서 값을 받기 위한 변수가 아닌가?
    // 그럼 외부에서 값을 받았으면 그 값을 그대로 사용해야지
    // 개발자가 값을 바꾸면 되겠는가?
    // 실수로라도 값을 못바꾸게 해야 하는 것 아닌가?
    //money = 100; // 이런 실수 못합니다!
    
    
    
    return money + (money * interest);
  }
  
}






