/* 인터페이스 사용 전 
 * => CarTester에서 Tesla 자동차도 테스트하게 만들어 보자!
 * => 방법?
 *    - Tesla를 Engine의 자식 클래스로 만든다.
 *    - 대신 Tesla는 Motor를 상속 받는 것을 포기해야 한다.
 *      포기하더라도 전기 자동차이기 때문에 Motor 기능을 
 *      Tesla에서 모두 재작성해야 한다.
 *    - 아 피곤하다. 
 *      Motor의 상속을 포기하는 댓가로 
 *      Motor의 모든 기능을 Tesla에서 재작성해야 한다.
 *      그리고 전기 자동차의 몸에 맞지 않는 start(), stop() 기능을 구현해야 하니
 *      유지보수에 좋은 않은 코드를 작성하게 된다. 
 */
package step18.ex3;

public class Test01 {

  public static void main(String[] args) {
    // 자동차 객체 준비
    Tico tico = new Tico();
    Truck truck = new Truck();
    
    // 자동차 시험소에서 자동차를 테스트한다.
    CarTester.test(tico);
    CarTester.test(truck);
    
    // 내연 기관을 사용하는 것처럼 전기 자동차를 개조하였다.
    Tesla tesla = new Tesla();
    
    // 이제는 자동차 시험소에서 전기 자동차를 테스트 할 수 있다.
    // 왜? Tesla는 Car의 서브 클래스이기 때문이다.
    CarTester.test(tesla);
    
    
    /* 기존에 만든 프로그램에 새 기능을 추가하는 경우,
     * 어떤 기능은 기존의 코드를 손대지 않고 추가할 수 있을 것이다.
     * 또 어떤 기능은 이렇게 기존 코드 변경해야 한다.
     * 기존 코드를 변경할 때 최소로 손을 대는 것이 좋다.
     * 많이 바꾸면 바꿀 수록 버그가 발생할 가능성이 높아진다.
     * 즉 기존에 잘 되던 기능도 변경 때문에 동작이 안되거나 잘못 동작할 수 있다는 것이다.
     * 
     * 그래서 기능을 추가하기 위해 기존 코드를 손대더라도 
     * "가능한 최소의 변경으로 새 기능을 추가하는 것"이 좋은 코드이다.
     * 
     * ex2 패키지에서는 CarTester 클래스에 Tesla를 테스트는 메서드를 추가하였다.
     * 문제는, 앞으로 다른 종류의 클래스가 등장할 때마다 
     * 계속 CarTester에 그에 맞는 test() 메서드를 추가해야 하는 문제가 있다.
     * 
     * ex3 패키지에서는 CarTester 클래스를 변경하지는 않았다.
     * 문제는, 기존의 CarTester.test() 메서드에 맞추기 위해
     * Tesla 클래스가 Motor 클래스의 상속을 포기하고
     * Engine 클래스의 자식 클래스로 만들었다는 점이다.
     * 만약 Motor 클래스에 기능이 무진장 많이 있었다면,
     * Tesla 클래스에 그 코드를 모두 동일하게 넣어야 한다는 것이다.
     * 기존의 상속을 포기하는 댓가가 너무 크다!
     * 
     * 해결책?
     * - 좀더 실력있는 개발자라면 이런 상황까지 어느 정도 고려해서 설계를 할 것이다.
     *   특히 테스트를 할 때 특정 클래스를 고집하기 보다는 
     *   그런 기능을 갖춘 자동차라면 어떤 클래스의 자식이든 테스트 할 수 있도록 프로그래밍 하였을 것이다.
     * - 결국, 설계 잘하자!
     *   그런데 설계하는데 기존의 클래스 문법만으로는 한계가 있더라!
     *   그래서 새로운 문법이 등장하였으니, 그 이름도 유명한 "인터페이스(interface)"이다.
     * 
     */
    
  }

}







